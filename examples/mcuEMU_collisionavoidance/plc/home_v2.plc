###############################################################################################
# For help on syntax, variables and functions, please read the file: "plcSyntaxHelp.plc"
#
# PLC Functionality Demo:
#
#   Code Description:
#     1. Check if EMU axes are in Low Limit Switch Position and properly homed. When this is tru the procedure is finished
#        1.a: if they are not homed and in the LLS, find out which oner is not placed
#        1.b: If axis 2 is not in place go to step 2, if axis 1 is inot in places go to step 6
#     2. Enable axis 2
#     3. Start home procedure for Axis 2
#     4. Move the Axis 2 to LLS
#     5. Make sure axis 2 is in LLS
#     6. Enable Axis 1
#     7. Start home procedure for Axis 1
#     8. Move the Axis 1 to LLS
#     9. Make sure Axis 1 is in LLS
#     

var errorCode:=0;

##### 0. Put all initiations here
if(plc0.firstscan){  
  println('Starting PLC motion example!!');
  #Ignore commands during startup sequence
  ax2.blockcom:=1;
  static.seqStep:=1;
  static.cycleCounter:=0;
  static.epicsDisableSeq:=0;
};

if(static.epicsDisableSeq){
  static.seqStep:=100;  #invalid
};

if(static.seqStep==1) 
{
   if(not(ax1.mon.lowlim) and not(ax2.mon.lowlim))
   {
   println('The Axes are in the LLS \n Are they homed?');
     if(ax1.enc.homed and ax2.enc.homed)
     {
       println('The startup sequence was succesfull');
       static.seqStep:=10;
       ax1.blockcom:=0;         # Allow commands again
       ax2.blockcom:=0;         # Allow commands again
       plc0.enable:=0;          # Disable PLC
     }
     else 
     {
     println('Start the homing sequence');
       if(not(ax1.enc.homed))
       {
       println('Homing sequence Axis 1');
       static.seqStep:=6;
       };
       if(not(ax2.enc.homed))
       {
       println('Homing sequence Axis 2');
       static.seqStep:=2;
       };
     };
   }
   else 
   {
      if(not(ax1.mon.lowlim) or not(ax2.mon.lowlim)) 
      {
	println('At least on of the axes is in LLS.\n The collsision avoidance start up procedure beggins');
   	if(not(ax1.mon.lowlim))
   	{
   	println('Axis 1 is in LLS, starting the homing procedure for the Axis 2');
   	static.seqStep:=2;
	};
	if(not(ax2.mon.lowlim))
   	{
   	println('Axis 1 is in LLS, starting the homing procedure for the Axis 2');
   	static.seqStep:=6;
	};
      };
   };		
};

##### Put power on axis 2 (run mc_power())
if(static.seqStep==2)
{
  if(not(ax2.error))
  {
    errorCode=mc_power(2,1);
    if(errorCode)
    {
      println('Function mc_power() returned error: ', errorCode);
      plc0.error:=errorCode;
    };
  }
  else
  {
    ax2.reset:=1;
  };
  if(ax2.drv.enabled){
    static.seqStep:=3;
    println('2. Function mc_home()  triggered!');
  };
};

##### 2. Do homing sequence (run mc_home())
if(static.seqStep==3)
{
  var homingSeq:=1;
  var velTwoardsCam:=1;
  var velOffCam:=1;
  errorCode=mc_home(2,1,homingSeq,velTwoardsCam,velOffCam);
  if(errorCode){
    println('Function mc_home() returned error: ', errorCode);
    plc0.error:=errorCode;
  };
  if(ax2.enc.homed and not(mc_get_busy(2)))
  {
    static.seqStep:=4;
    println('3. Function mc_move_abs()  triggered!');
  };
};

##### 3. Trigger a absolute move to reach LLS
if(static.seqStep==4){
  println('sequence 3 entered');
  ax2.blockcom:=0;  #Allow EPICS control
  var posTarg:=-10;
  var vel:=1;
  var acc:=100;
  var dec:=100;
  errorCode:=mc_move_abs(2,1,posTarg,vel,acc,dec);
  if(errorCode){
    println('Error: mc_move_abs() returned error: ',errorCode);
    plc0.error:=errorCode;
  };
 static.seqStep:=5;
};


##### 4. wait until LLS is reached
if(static.seqStep==5){
  var posTarg:=-10;
  var vel:=1;
  var acc:=100;
  var dec:=100;
 #Finish the sequence with error if the LLS is not hit before axis arrives to absolute position
  if(ax2.traj.setpos==posTarg and not(mc_get_busy(2)))
  {
  println('absolute position reached before the LLS');
  mc_move_abs(2,0,posTarg,vel,acc,dec);  # Set execute low
  println('Sequence ended because limit switch was not reached. ErrorCode:', errorCode);
    errorCode=mc_power(2,0);               # disable axis power
  if(errorCode)
  {
    println('Function mc_power() returned error: ', errorCode);
    plc0.error:=errorCode;
  };
  println('Sequence ended because limit switch was not reached. ErrorCode:', errorCode);
  static.seqStep:=10;      # Sequence end
  ax2.blockcom:=0;         # Allow commands again
  plc0.enable:=0;          # Disable PLC
  };
  if(not(ax2.mon.lowlim))
  {
  println('LLS hitted stop the plc code');
  mc_move_abs(2,0,posTarg,vel,acc,dec);  # Set execute low
  errorCode=mc_power(2,0);               # disable axis power
  if(errorCode)
  {
    println('Function mc_power() returned error: ', errorCode);
    plc0.error:=errorCode;
  };
  static.seqStep:=1;      # Sequence end
  };
};



##### Put power on axis 1 (run mc_power())
if(static.seqStep==6)
{
  if(not(ax1.error))
  {
    errorCode=mc_power(1,1);
    if(errorCode)
    {
      println('Function mc_power() returned error: ', errorCode);
      plc0.error:=errorCode;
    };
  }
  else
  {
    ax1.reset:=1;
  };
  if(ax1.drv.enabled){
    static.seqStep:=7;
    println('2. Function mc_home()  triggered!');
  };
};

##### 2. Do homing sequence (run mc_home())
if(static.seqStep==7)
{
  var homingSeq:=1;
  var velTwoardsCam:=1;
  var velOffCam:=1;
  errorCode=mc_home(1,1,homingSeq,velTwoardsCam,velOffCam);
  if(errorCode){
    println('Function mc_home() returned error: ', errorCode);
    plc0.error:=errorCode;
  };
  if(ax1.enc.homed and not(mc_get_busy(1)))
  {
    static.seqStep:=8;
    println('3. Function mc_move_abs()  triggered!');
  };
};

##### 3. Trigger a absolute move to reach LLS
if(static.seqStep==8){
  println('sequence 8 entered');
  ax2.blockcom:=0;  #Allow EPICS control
  var posTarg:=-10;
  var vel:=1;
  var acc:=100;
  var dec:=100;
  errorCode:=mc_move_abs(1,1,posTarg,vel,acc,dec);
  if(errorCode){
    println('Error: mc_move_abs() returned error: ',errorCode);
    plc0.error:=errorCode;
  };
 static.seqStep:=9;
};


##### 4. wait until LLS is reached
if(static.seqStep==9){
  var posTarg:=-10;
  var vel:=1;
  var acc:=100;
  var dec:=100;
 #Finish the sequence with error if the LLS is not hit before axis arrives to absolute position
  if(ax1.traj.setpos==posTarg and not(mc_get_busy(1)))
  {
  println('absolute position reached before the LLS');
  mc_move_abs(1,0,posTarg,vel,acc,dec);  # Set execute low
  println('Sequence ended because limit switch was not reached. ErrorCode:', errorCode);
    errorCode=mc_power(1,0);               # disable axis power
  if(errorCode)
  {
    println('Function mc_power() returned error: ', errorCode);
    plc0.error:=errorCode;
  };
  println('Sequence ended because limit switch was not reached. ErrorCode:', errorCode);
  static.seqStep:=10;      # Sequence end
  ax2.blockcom:=0;         # Allow commands again
  plc0.enable:=0;          # Disable PLC
  };
  if(not(ax1.mon.lowlim))
  {
  println('LLS hitted stop the plc code');
  mc_move_abs(1,0,posTarg,vel,acc,dec);  # Set execute low
  errorCode=mc_power(1,0);               # disable axis power
  if(errorCode)
  {
    println('Function mc_power() returned error: ', errorCode);
    plc0.error:=errorCode;
  };
  static.seqStep:=1;      # Sequence end
  };
};

return [];

println('NEVER HERE');
